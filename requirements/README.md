# Requirement structure

## Background

Boardfarm, with the standardization of the test interface, supports an highly efficient process to automate test cases. In this section we are proposing a structure to capture the system requirements in a way to:

1. clearly link the test cases to the requirements
2. capture the requirements in a git-friendly format
3. maximize the efficiency of converting the requirement to automated test cases
4. facilitate automated checks in terms of requirements coverage

**PLEASE NOTE:**
The below is an suggestion to organize requirement and test cases.
Most of the test cases listed in this repository are not (yet) linked to requirements in the way it is suggested here. The Requirement Use cases and the associated tests are examples of how this could be done. The associated automated test cases have been generated by (with the help of) AI.

## Link test cases to requirements

Requirements lead the definition of how the system should behave and is the result of the collaboration of many stakeholders, In order to have a traceable understanding as to how well the test suite is covering the system requirements, it makes sense to link the two.

### Traceability through Custom Decorators

To create a direct link between a use case scenario and the code that tests it, we use a custom `@requirement` decorator. This allows for precise traceability and the ability to selectively run tests based on requirements.

**1. The `@requirement` Decorator**

The decorator links a test function to a specific use case and scenario. It takes two arguments: the use case ID and a string describing the scenario.

-   `use_case_id` (str): The identifier of the use case (e.g., `"UC-12345"`).
-   `scenario` (str): A description of the scenario covered by the test (e.g., `"Main Success Scenario"` or `"Extension 2a: Rollback on failure"`).

**2. Applying the Decorator to a Test**

To tag a test function, apply the `@requirement` decorator directly above the function definition. You will also need to import the decorator from `lib.decorators`.

```python
from lib.decorators import requirement
import pytest

@requirement("UC-12345", "Main Success Scenario")
@pytest.mark.env_req({"environment_def": {"board": {"lan_clients": [{}]}}})
def test_cpe_upgrade_preserve_settings():
    """
    This test covers the main success scenario for the CPE firmware upgrade.
    """
    # ... test implementation ...
```

**3. Running Tests Based on Use Cases**

You can execute a specific set of tests using the `--use-cases` command-line option in `pytest`. You can provide a single use case ID or a comma-separated list of IDs.

```bash
# Run all tests for use case UC-12345
pytest --use-cases "UC-12345"

# Run all tests for use cases UC-12345 and UC-12346
pytest --use-cases "UC-12345,UC-12346"
```

This approach provides a robust and clear method for ensuring that our test suite accurately reflects the documented system requirements.

## Test Suite Structure and Naming Convention

To ensure the test suite is well-organized, maintainable, and easy to navigate, we adopt a standardized structure based on the use cases.

### Guiding Principles

-   **Group by Use Case:** All tests related to a single use case (including its main success scenario and all extensions) should be located in the same test file. This improves code reusability for fixtures and helper functions and makes it easy to find all relevant tests for a feature.
-   **Clarity at a Glance:** The naming of files and functions should clearly communicate what feature and what specific behavior are under test.

### Naming Convention

We use a three-tiered approach to link a test to a requirement:

1.  **File Name:** Uniquely identifies the use case.
    -   **Format:** `test_<use_case_id>_<short_description>.py`
    -   **Example:** `test_uc12345_cpe_upgrade.py`

2.  **Test Function Name:** Describes the specific scenario being tested.
    -   **Format:** `test_<scenario_description>`
    -   **Example:** `test_main_scenario_settings_preserved`
    -   **Example:** `test_ext_4a_rollback_on_connection_failure`

3.  **`@requirement` Decorator:** Provides the formal, machine-readable link to the requirement scenario for traceability and selective test execution. (See "Traceability through Custom Decorators" for more detail).
    -   **Example:** `@requirement("UC-12345", "Main Success Scenario")`

This structure creates a clear and logical mapping from high-level requirements down to the specific lines of code that verify them.

## Capture requirements in a git-friendly format

Requirements need, just like software, a solid version control system. By using Git as a version control system for requirements, it is possible to mange the requirements in the same repositories as the software development team. This increases the collaboration between the product management and engineering teams, and allows the documentation of every release to be up to date.
The proposal is to write requirements in Markdown text files as this format is highly portable and accessible by many different editors. (VSCode, Cursor, Obsidian, etc.)

## Maximize efficiency in generating automated test cases

By defining clear and complete descriptions as to how the system is to behave, it is possible to utilize LLM's to expedite the translation of these scenarios into scripts that leverage the standardized test interface defined by Boardfarm.
Please see a [use case template](Use Case Template (reflect the goal).md) as a possible way to accomplish this.
The template is based on the excellent work by Alistair Cockburn: "Writing Effective Use Cases"

## Facilitate automated checks in terms of requirements coverage

This is also enabled by the structured approach in defining how the system should behave and the interpretation of the functionality verified by the associated tests. The file formats and the definition of the standardized test interface allow for a very efficiently verification process with the use of LLM's

## Use case structure for requirements

Each use case should have the following elements:

| Paragraph title                     | Intended content                                                                                                                                                                                                        |
| ----------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Use case name and goal              | A clear and short descriptor indicating what the goal of the use case is - should also be reflected in the name of the use case file                                                                                    |
| Primary Actor                       | Specifies who the primary actor is trying the achieve the goal                                                                                                                                                          |
| Stakeholders                        | Identifies the other stakeholders having an interest in the the use case                                                                                                                                                |
| Level                               | The level of the use case: summary, user-goal or sub-function                                                                                                                                                           |
| Preconditions                       | What we expect is already the state of the world                                                                                                                                                                        |
| Minimal Guarantees                  | How the interests of all actors and stakeholders are protected under all exits of the use case                                                                                                                          |
| Success Guarantees                  | The state of the world if the goal of the use case is achieved                                                                                                                                                          |
| Trigger                             | What starts the use-case - could be a time-trigger as well as an action by an actor.                                                                                                                                    |
| Main Success Scenario               | List of steps from trigger to goal delivery and any cleanup after                                                                                                                                                       |
| Extensions                          | *Optional:* List of extensions referencing the relevant step in the main scenario<br>Also possible to list extensions on extensions - be careful not to extend too deeply; use reference to a separate use-case instead |
| Technology and Data variations list | *Optional:* Put here the variations that will cause eventual bifurcation in the scenario                                                                                                                                |
| Related information                 | *Optional:* Any additional information related to the use case needed.                                                                                                                                                  |
